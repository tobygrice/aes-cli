use std::vec;

use rand::TryRngCore;
use rand::rngs::OsRng;

use super::constants::{RCON, SBOX};
use super::error::{Error, Result};

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum KeySize {
    Bits128,
    Bits192,
    Bits256,
}

impl KeySize {
    pub const fn bytes(self) -> usize {
        match self {
            KeySize::Bits128 => 16,
            KeySize::Bits192 => 24,
            KeySize::Bits256 => 32,
        }
    }
}

pub fn random_key(keysize: KeySize) -> Result<Vec<u8>> {
    let mut key = vec![0u8; keysize.bytes()];
    OsRng.try_fill_bytes(&mut key)?;
    Ok(key)
}

pub fn expand_key(key: &[u8]) -> Result<Vec<[[u8; 4]; 4]>> {
    match key.len() {
        16 | 24 | 32 => {}
        n => return Err(Error::InvalidKeyLength { len: n }),
    }

    // Variable names match FIPS-197, NIST specification: https://doi.org/10.6028/NIST.FIPS.197-upd1
    // Nk   The number of 32-bit words comprising the key
    // Nr   The number of rounds. 10, 12, and 14 for AES-128, AES-192, and AES-256, respectively
    // w    The result of the key schedule, an array of words that form round keys
    // Nw   The total number of words generated by the key schedule (including initial key)
    let nk = key.len() / 4; // key size (in 4-byte words)
    let nr = nk + 6; // number of rounds = num of words in key + 6
    let nw = (nr + 1) * 4; // total number of words resulting from expansion

    // initialise w, flat vector comprising words of round_keys
    let mut w: Vec<[u8; 4]> = vec![[0u8; 4]; nw];

    // first nk words of w are filled with the initial key
    for i in 0..key.len() {
        w[i / 4][i % 4] = key[i];
    }

    // initialise temp variable
    let mut temp = w[nk - 1];
    for i in nk..nw {
        if i % nk == 0 {
            // calculate rot_word, sub_word, and rcon on temp
            temp = [
                SBOX[temp[1] as usize] ^ RCON[i / nk],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
                SBOX[temp[0] as usize],
            ];
        } else if nk == 8 && i % nk == 4 {
            // additional substitution on temp for AES-256 only
            temp = [
                SBOX[temp[0] as usize],
                SBOX[temp[1] as usize],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
            ];
        }

        // w[i] = temp ⊕ w[i − Nk]
        w[i] = xor_words(&temp, &w[i - nk]);
        temp = w[i]; // update temp
    }

    // convert flat words vector into indexable round_keys vector
    let mut round_keys: Vec<[[u8; 4]; 4]> = vec![[[0u8; 4]; 4]; nr + 1];
    for i in 0..nw {
        round_keys[i / 4][i % 4] = w[i];
    }
    
    Ok(round_keys)
}

#[inline(always)]
pub fn add_round_key(state: &mut [[u8; 4]; 4], round_key: &[[u8; 4]; 4]) {
    for i in 0..4 {
        state[i] = xor_words(&state[i], &round_key[i]);
    }
}

#[inline(always)]
fn xor_words(a: &[u8; 4], b: &[u8; 4]) -> [u8; 4] {
    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn key_schedule_128() -> Result<()> {
        // run key schedule on 128 bit sample key from FIPS-197 Appendix A.1
        let key_128: [u8; 16] = [
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf,
            0x4f, 0x3c,
        ];

        let round_keys = expand_key(&key_128)?;
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.1
        let expected: [[u8; 4]; 4] = [
            [0xd0, 0x14, 0xf9, 0xa8],
            [0xc9, 0xee, 0x25, 0x89],
            [0xe1, 0x3f, 0x0c, 0xc8],
            [0xb6, 0x63, 0x0c, 0xa6],
        ];

        assert_eq!(last, expected);

        Ok(())
    }

    #[test]
    fn key_schedule_192() -> Result<()> {
        // run key schedule on 192 bit sample key from FIPS-197 Appendix A.2
        let key_192: [u8; 24] = [
            0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90,
            0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b,
        ];

        let round_keys = expand_key(&key_192)?;
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.2
        let expected: [[u8; 4]; 4] = [
            [0xe9, 0x8b, 0xa0, 0x6f],
            [0x44, 0x8c, 0x77, 0x3c],
            [0x8e, 0xcc, 0x72, 0x04],
            [0x01, 0x00, 0x22, 0x02],
        ];

        assert_eq!(last, expected);

        Ok(())
    }

    #[test]
    fn key_schedule_256() -> Result<()> {
        // run key schedule on 256 bit sample key from FIPS-197 Appendix A.3
        let key_256: [u8; 32] = [
            0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d,
            0x77, 0x81, 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3,
            0x09, 0x14, 0xdf, 0xf4,
        ];

        let round_keys = expand_key(&key_256)?;
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.3
        let expected: [[u8; 4]; 4] = [
            [0xfe, 0x48, 0x90, 0xd1],
            [0xe6, 0x18, 0x8d, 0x0b],
            [0x04, 0x6d, 0xf3, 0x44],
            [0x70, 0x6c, 0x63, 0x1e],
        ];

        assert_eq!(last, expected);

        Ok(())
    }

    #[test]
    fn test_random_key() -> Result<()> {
        for _ in 0..100 {
            assert_eq!(
                random_key(KeySize::Bits128)?.len(),
                16,
                "128 bit random key is not 16 bytes long"
            );
            assert_eq!(
                random_key(KeySize::Bits192)?.len(),
                24,
                "192 bit random key is not 24 bytes long"
            );
            assert_eq!(
                random_key(KeySize::Bits256)?.len(),
                32,
                "256 bit random key is not 32 bytes long"
            );
        }
        Ok(())
    }
}
